Volatile tests howto:

- We use pintool to do volatile tests. 

  Prepare pintool:

  * suppose the $PIN_HOME is where pintool is going to be installed
  * cd $PIN_HOME
  * download pintool from:
    wget http://software.intel.com/sites/landingpage/pintool/downloads/pin-2.12-55942-gcc.4.4.7-linux.tar.gz

  * cp pin.sh to $PIN_HOME/
    (note: the new pin.sh only work on 64-bit system)

  * cp pinatrace.cpp to $PIN_HOME/source/tools/ManualExamples/
  * cd $PIN_HOME/source/tools/ManualExamples
  * make
    (note: this will build intel64 obj. 
     If you want to build ia32 obj, then do:
     TARGET=ia32 make
    )

  To do volatile tests using volatile scripts, you only need to 
  modify some scripts in csmith/utah/scripts/old_john_driver

  * open evaluate_program.pl: 
  change 
    my $CHECK_VOLATILE = $NO_VOLCHECK;
  to
    my $CHECK_VOLATILE = $USE_VOLCHECK;
    
  * open random_test.pl
  change:
    my $use_pintool = 0;
  to
    my $use_pintool = 1;

  (enabling it will pass "--enable-volatile-tests [x86|x86_64] --vol-addr-file vol_addr.txt" to csmith)

  * do normal test using launchn.pl

Some details about pinatrace:

  How to invoke pinatrace hack standalone:
  
  $PIN_HOME/pin -t $PIN_HOME/source/tools/ManualExamples/obj-intel64/pinatrace.so -vol_input vol_addr.txt [-output_mode checksum|verbose|summary] [-random_read] [-seed num] -- ./a.out

  on the latest Ubuntu 12.04.1, we have to use the following command:
  
  $PIN_HOME/pin -injection child -t $PIN_HOME/source/tools/ManualExamples/obj-intel64/pinatrace.so -vol_input vol_addr.txt [-output_mode checksum|verbose|summary] -- ./a.out 

  (note: replace intel64 with ia32 if you are on a 32-bit machine)

  where:
    vol_addr.txt is generated by random programs which contains volatile addresses,

  *  -output_mode checksum [default]
    Compute a checksum over the numbers of reads/writes to volatile locations

  *  -output_mode summary
    In the summary mode, only the number of a volatile access will be 
    dumped. Volatile accesses are measured byte-wise, and reads/writes
    are aggregate counts over the entire run of a test case. For example:

    volatile int g;

    Then pintool will output something like:

    &g: 0: 1 reads, 0 writes
    &g: 1: 1 reads, 0 writes
    &g: 2: 1 reads, 0 writes
    &g: 3: 1 reads, 0 writes
  
    where the numbers on the second col are sequence number of g, 0 means that its the first byte of g, 
    1 means the second byte of g, and so on.

  *  -output_mode verbose
    In the verbose mode, all values to be loaded and stored are also dumped.
    I didn't integrate the support to the verbose mode into volatile scripts. So the current 
    volatile testing only work in the summary mode. 

  * -random_read
    pass random values to volatile reads rather than original values
    To see how it work, you can try rand_val_test1.c:

    (1) gcc rand_val_test1.c
    (2) $PIN_HOME/pin.sh -injection child -t $PIN_HOME/source/tools/ManualExamples/obj-intel64/pinatrace.so -vol_input vol_addr.txt -output_mode checksum -random_read -- ./a.out

  * -seed num  
    pintool will use the passed seed rather than a random one

